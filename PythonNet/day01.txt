吕泽
    lvze@tedu.cn

一、本阶段课程安排和特点

1.网络编程 （4天）
2.进程线程  （5天）
3.MongoDB 数据库 （4天）
4.正则表达式 （1.5天）
5.git的使用（1天）
6.项目（2.5天）

-----------------------------------------------------------------------------------------------------

二、网络编程
１、网络功能 : 数据传输
２．ISO(国际标准化组织International Organization for Standards)给出以下通信标准：七层模型

３．OSI(Open System Interconnection)七层模型 ---》 目的：使网络通信工作流程的标准化

应用层 ： 提供用户服务，具体功能由特定的程序而定
表示层 ： 数据的压缩优化，加密
会话层 ： 建立应用级的连接，选择传输服务
传输层 ： 提供不同的传输服务。流量控制
网络层 ： 路由选择，网络互连
链路层 ： 进行数据转换，具体消息的发送，链路连接
物理层 ： 物理硬件，接口设定，网卡路由交换机等

４．cookie
高内聚 ：模块功能尽可能单一，不要相互掺杂
低耦合 ：模块之间尽可能减少关联和影响

５．OSI七层模型优点 ：  
1. 建立了统一的工作流程　　　　　　　　
2.分步清晰每一步各司其职                                  
3.降低了模块间的耦合度，使每一部分可以单独开发，单独工作。


６．四层模型(TCP/IP模型)
应用层  ： *将应用层，表示层，会话层统一由应用层完成，便于应用层的开发
传输层
网络层
物理链路层

７．五层模型（TCP/IP模型）
应用层(集应用层/表示层/会话层功能于一体，功能为)：提供用户服务，具体功能由特定的程序而定,数据的压缩、优化、加密，建立应用级的连接，选择传输服务
传输层：提供不同的传输服务和流量控制
网络层：进行路由选择和网络互连
链路层：对具体消息进行数据转换，消息发送进行链路连接
物理层：指物理硬件、接口设定，网卡、路由器、交换机等
-----------------------------------------------------------------------------------------------------
三、数据传输流程

1. 发送端由应用层到物理层逐层添加信息头（首部信息），最终在物理层发送消息包。
2.发送的消息中间经过多个节点传送（路由基站交换机等）最终到达目标主机
3.目标主机逐层解析消息包，最终由应用层呈现数据信息

网络协议ip：
网络通信中双方都遵循的规定。包括建立什么样的数据结构，消息结构等


应用层 ： TFTP  HTTP  DNS   SMTP(邮件发送协议)
传输层 ： TCP   UDP
网络层 ： IP 
物理层 ： IEEE

-----------------------------------------------------------------------------------------------------

四、网络编程相关概念
模块
①网络主机 ： 
    在网络中标识一台计算机    HOST

②本地连接使用 ：
    'localhost'
    '127.0.0.1'
③网络连接使用 :
     '0.0.0.0'  
    '176.234.96.87'

    ifconfig  ： 查看本机的IP信息
    
    通过python获取计算机名
    In [3]: socket.gethostname()
    Out[3]: 'tedu'
    
    通过计算机名获取地址
    In [5]: socket.gethostbyname('localhost')
    Out[5]: '127.0.0.1'
    

④IP地址
    网络上确定一台主机网络路由位置的地址
    
    IPv4 ： 点分十进制  192.168.1.2  每个部分的范围是0--255
    
    IPv6 ： 128位
    
    ping  ip（连接测试命令）  ： 测试和某台网络主机是否联通
    
⑤特殊IP地址

    127.0.0.1  本地本机测试IP
    0.0.0.0   使用本机能够使用的网卡地址
    192.168.1.0  表示一个网段IP 
    192.168.1.1  通常表示网关地址（路由地址）
    192.168.1.255  广播地址
    
    
    通过地址获取主机网络信息
    In [7]: socket.gethostbyaddr('www.baidu.com')
    Out[7]: ('127.0.0.1', [], ['119.75.216.20'])
              主机名     别名   网络地址
    
    点分十进制地址转换为二进制
    In [9]: socket.inet_aton('192.168.1.2')
    Out[9]: b'\xc0\xa8\x01\x02'
    
    二进制地址转换为点分十进制
    In [10]: socket.inet_ntoa(b'\xc0\xa8\x01\x02')
    Out[10]: '192.168.1.2'
  
⑥域名 ： 
    网络服务器地址的名称
    1. 方便记忆
    2. 名称表达一定的含义

⑦网络端口号port：
    端口是网络地址的一部分，用于区分一个网络主机上不同的网络应用程序
    * 在一个操作系统中不同的网络应用监听不同的端口号
    
    取值范围 ： 1--65535
        1--255   一些众所周知的通用端口
        256--1023   系统应用端口
        1024 ---65535  自用端口
        建议使用  >10000 
    
    获取一个应用的端口信息
    In [11]: socket.getservbyname('mysql')
    Out[11]: 3306


⑧网络字节序 ： 
    数据在网络中的传输格式

-----------------------------------------------------------------------------------------------------

五、传输层服务
1.传输服务分类：
    1.面向连接的传输服务：基于tcp协议的数据传输
        1.传输特征： 提供可靠的数据传输，可靠性指数据传输过程中无丢失，无失序，无差错，无重复。 
        2.实现手段： 在通信前需要建立数据连接，通信结束需要正常断开连接
        3.把建立连接的过程形象的称为:三次握手：
            三次握手 ： tcp传输在数据传输前建立连接的过程
            第1次握手. 客户端向服务器发送连接标识变量表示请求连接 
            第2次握手. 服务器收到请求后，回复变量标志确定可连接
            第3次握手. 客户端收到服务器回复，发送最终连接标志建立连接
        4.断开连接的过程形象的称为:四次握手
            四次挥手 ： tcp传输在连接断开前进行断开确认的过程
            第1次握手. 主动发发送标志表示请求断开连接
            第2次握手. 被动方收到请求后，立即回复信息表示已经接受请求
            第3次握手. 被动方信息处理完毕，再次发送标志表示已经准备可以断开
            第4次握手. 主动方收到被动方标志，发送最终断开标志，连接断开
        
        5.tcp应用情况 ： 适用于传输较大的文件，网络情况良好，需要保证传输可靠性的情况。
        比如： 网页的获取，文件下载，邮件传输，登录注册

    2.面向无连接的传输服务：基于udp协议的传输
        1.传输特点 ： 不保证传输的可靠性，传输过程没有连接和断开的流程，数据收发自由。
        2.udp适用情况 ： 
        适用udp:网络情况较差，对传输可靠性要求不高，需要提升传输效率。不便连接，需要灵活收发消息。
               比如：网络视频，群聊，广播发送，
     


六、socket模块
    socket套接字编程

    目标： 根据socket模块提供的接口函数，进行组合搭配使用完成基于tcp或者udp的网路套接字编程。
    
    套接字：实现网络编程，进行数据传输的一种技术手段

    套接字分类：
        流式套接字（SOCK_STREAM）: 传输层基于tcp协议 的套接字编程方案。
	    数据报套接字（SOCK_DGRAM）: 传输层基于udp协议的套接字编程方案。
	    底层套接字（SOCK_RAM）：访问底层协议的套接字编程。
    
     * 面向连接的传输--tcp协议--可靠地--流式套接字
     * 面向无连接传输--udp协议--不可靠--数据报套接字



七、tcp套接字服务端编程

import  socket

1.创建套接字:
    sockfd = socket.socket(socket_family = AF_INET,socket_type = SOCK_STREAM,proto = 0)
    功能 ： 创建套接字
    参数 ：  socket_family : 选择地址族类型  AF_INET(表示用ipv4地址，若常量为AF_INET6表示用ipv6地址)
            socket_type :   套接字类型 SOCK_STREAM 流式
    	                　　　　　     SOCK_DGRAM 数据报
            proto : 选择子协议类型  通常为0
    返回值 ： 返回套接字对象


2. 绑定服务端地址ip和port
    sockfd.bind(addr)
    功能 ： 绑定IP地址
    参数 ： 元组  （ip，port）('192.168.56.140',8888)
    
    localhost-->           可以被本机用  127.0.0.1
    127.0.0.1-->           同上
    192.168.205.127-->     可以被所有人用192.168.205.127访问
    0.0.0.0 -->            可以被所有人用192.168.205.127访问
            -->            也可被自己用127.0.0.1访问

3. 设置监听套接字
    sockfd.listen(n)
    功能：将套接字设置为监听套接字，创建监听队列
    参数：n 设置监听队列大小
    
    * 一个监听套接字可以连接多个客户端套接字
    
4. 等待处理客户端连接请求
    connfd，addr = sockfd.accept()
    功能 ： 阻塞等待处理客户端连接
    返回值： connfd  连接的客户端的连接套接字
             addr   连接的客户端地址
    
    * 阻塞函数 ： 程序运行过程中遇到阻塞函数则暂停运行，直到某种阻塞条件达成再继续运行。

5. 消息收发

    data = connfd.recv(buffersize)
    功能 ： 接收对应客户端消息
    参数 ： 一次最多接收多少字节
    返回值 ： 接收到的内容
    
    * 如果没有消息则会阻塞
    
    n = connfd.send(data)
    功能 ： 发送消息给对应客户端
    参数 ： 要发送的内容，必须是bytes格式
    返回值 ： 返回实际发送消息的大小（多少个字节）

6. 关闭套接字
    connfd.close()
    sockfd.close()
    功能： 关闭套接字

####程序示例：
------------------------------------------------------------------------
import socket
# 创建套接字
sockfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# 设置绑定地址
sockfd.bind(('0.0.0.0', 8888))

# 设置监听
sockfd.listen(5)

print('Waiting for connect...')
# 等待处理客户端的连接
connfd, addr = sockfd.accept()
print('Connect from', addr)  # 客户端地址

# 收发消息
data = connfd.recv(1024)
print('Receive message:\n', data.decode())

n = connfd.send('Receive your message'.encode())
print('Send %d bytes' % n)

# 关闭套接字
connfd.close()
sockfd.close()
-----------------------------------------------------------------------------




八、tcp套接字客户端编程
1. 创建套接字
   * 必须相同类型的套接字才能通信
2. 建立连接
   sockfd.connect(servr_addr)
   功能 ： 建立连接服务端
   参数 ： 元组， 服务端地址
3. 消息收发
   * 消息收发要和服务端配合，避免两边都出现recv阻塞
4. 关闭套接字

####程序示例：
--------------------------------------------------------------------------
from socket import *
#创建客户端的套接字
sockfd=socket()

#发起连接到服务ip
server_addr=('127.0.0.1',8888)
sockfd.connect(server_addr)

#发／收消息
data=input('>>你好')
sockfd.send(data.encode())
data=sockfd.recv(1024)
print('From server:',data.decode())

sockfd.close()
----------------------------------------------------------------------------
作业 ： 
1. 总结口述方案

    ①osi七层模型和tcp/ip模型:
----------------------------------------------------------------------------
OSI(Open Systerm Interconnection)七层模型:
应用层 ： 提供用户服务，具体功能由特定的程序而定
表示层 ： 数据的压缩优化，加密
会话层 ： 建立应用级的连接，选择传输服务
传输层 ： 提供不同的传输服务。流量控制
网络层 ： 路由选择，网络互连
链路层 ： 进行数据转换，具体消息的发送，链路连接
物理层 ： 物理硬件，接口设定，网卡路由交换机等
-----------------------------------------------------------------------------
TCP/IP(Transfer Control Protocol/Internet Protocol)五层模型模型:
应用层(集应用层/表示层/会话层功能于一体，功能为)：提供用户服务，具体功能由特定的程序而定,数据的压缩、优化、加密，建立应用级的连接，选择传输服务
传输层：提供不同的传输服务和流量控制
网络层：进行路由选择和网络互连
链路层：对具体消息进行数据转换，消息发送进行链路连接
物理层：指物理硬件、接口设定，网卡、路由器、交换机等
-----------------------------------------------------------------------------

    ②三次握手和四次握手过程:
-----------------------------------------------------------------------------
基于TCP(Transfer Control Protocol)协议的数据传输 
在通信前建立连接确认的过程称为“三次握手”，
在结束通信时断开连接确认的过程称为“四次握手”
①三次握手 ： tcp传输在数据传输前建立连接的过程
  第1次握手. 客户端向服务器发送连接标识变量表示请求连接 
  第2次握手. 服务器收到请求后，回复变量标志确定可连接
  第3次握手. 客户端收到服务器回复，发送最终连接标志建立连接
②四次挥手 ： tcp传输在连接断开前进行断开确认的过程
  第1次握手. 主动发发送标志表示请求断开连接
  第2次握手. 被动方收到请求后，立即回复信息表示已经接受断开请求，即将为断开请求做信息处理
  第3次握手. 被动方信息处理完毕，再次发送标志表示已经准备可以断开
  第4次握手. 主动方收到被动方标志，发送最终断开标志，连接断开
-----------------------------------------------------------------------------

    ③tcp和udp的区别
-----------------------------------------------------------------------------
传输层：选择传输服务，进行流量控制
传输服务分为：		
①面向连接的传输服务--基于tcp协议
--提供可靠的数据传输(数据传输过程中无丢失、无失序、无差错、无重复)
--选择流式套接字编程方案
--适用于适用于传输较大的文件，网络情况良好，需要保证传输可靠性的情况；比如： 网页的获取，文件下载，邮件传输，登录注册
②面向无连接传输服务--基于udp协议
--不保证传输的可靠性，传输过程没有连接和断开的流程，数据收发自由
--选择数据报套接字编程方案
--适用于网络情况较差，对传输可靠性要求不高，需要提升传输效率；不便连接，需要灵活收发消息；比如：网络视频，群聊，广播发送
-----------------------------------------------------------------------------



2. 将完成的基本的tcp_server改写为一个，当客户端输入特殊字符退出后可以继续接受下个客户端请求的程序。
---------------------------------------tcp套接字服务器编程---------------------------------------
from socket import *
sockfd = socket(AF_INET, SOCK_STREAM)
sockfd.bind(('0.0.0.0', 8888))
sockfd.listen(5)
print('等待客户连接...')
connfd, addr = sockfd.accept()
print(addr,'已连接~')
while True:
    print('客户端:', connfd.recv(1024).decode())
    connfd.send(input('服务器:').encode())
connfd.close()
sockfd.close()
---------------------------------------tcp套接字客户端编程---------------------------------------
from socket import *
sockfd = socket(AF_INET, SOCK_STREAM)
sockfd.connect(('127.0.0.1', 8888))
while True:
    sockfd.send(input('客户端:').encode())
    print('服务器:', sockfd.recv(1024).decode())
sockfd.close()

3. 复习文件的读写seek操作
