day08回顾
 两个容器的类型
  set(可变集合)
  frozenset(不可编集合)
  　存储不可变数据的容器
  无序/不能存在重复元素
 运算
  ＆交集　|交集　-补集　^对称补集
  > < == != <= >=
  in/not in
 集合：
  {1,2,3}/set()
  frozenset({1,2,3})/frozenset()
 方法：
 S.add()
 S.remove()
 S.discard()
 S.clear()
 S.pop()
 S.copy()
 S.update()
 集合推导式：
 {x**2 for x in range(10)}
 函数：可以重复执行的具有一定功能的语句块
 　创建函数的语法：
 　def 语句：
 　def 函数名(形参1,形参变量2,...):
 　    语句块
 函数调用：
 　函数名(实参1,实参2,...)
 　表达式返回None
 return语句：
  作用：用于终止函数的执行，返回一个对象的引用关系（默认返回None）
===================================================================
day09笔记
函数的参数：
1.函数调用实际传递参数（把数据给函数）
2.函数的形式参数（从调用者接收的数据）
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
函数的实际调用参数传递
传递方式：
　1.位置传参
　　1.1序列传参
　2.关键字传参
　　2.2字典关键字传参
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
>>>>>>>>>>位置传参：
  　实际参数（实参）的对应关系与形式参数（形参）的对应关系是按位置来依次对应的
  实例：
  def mymin(a,b,c):
      pass
  #         ^ ^ ^
  mymin(    1,2,3)
  说明：实参个数必须与形参个数相同
  示例：
  ---------
  def myfun1(a,b,c):
      print('a的值是：',a)
      print('b的值是：',b)
      print('c的值是：',c)
      #位置传参
  myfun1(1,2,3)#1-->a 2-->b..
  -----------------
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
>>>>>>>>>>序列传参：
  　序列：字符串、列表、元祖
  　序列传参是指在函数调用过程中，用*(星号)将序列拆解后按位置进行传递的传参方式
  说明：
  　序列传参时，序列拆解的位置将与形参一一对应
  　序列的位置信息对应相应的参数位置　
  示例：
  --------
  def myfun1(a,b,c):
      print('a的值是：',a)
      print('b的值是：',b)
      print('c的值是：',c)
  s1=[11,22,33]
  myfun1(s1[0],s1[1],s1[2]) #位置传参的方式
  myfun1(*s1) #序列拆解元素位置传参
  --------
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝  
>>>>>>>>>>关键字传参：
   关键字传参是指传参时，按着形参的名称给形参赋值
   实参和形参按名称进行匹配
  示例：
  -------------
  def myfun1(a,b,c):
      print('a的值是：',a)
      print('b的值是：',b)
      print('c的值是：',c)
  myfun1(c=300,b=200,a=100)
  -------------
  说明：
   实参和形参可以不按照位置进行匹配
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
>>>>>>>>>>字典关键字传参：
  是指实参为字典，将字典用**（双星号）拆解后进行关键字传参的传参形式
  示例：
  ------------
  def myfun1(a,b,c):
    print('a的值是：',a)
    print('b的值是：',b)
    print('c的值是：',c)
  d1={'c':33,'b':22,'a':11}
  myfun1(**d1)
  ---------------
  说明：
  字典的键名和形参名必须一致
  字典的键名必须是字符串，且必须为标识符命名的规则
  字典的键名要在形参中存在
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
函数的综合传参：
 　函数的传参方式，在能确定形参能唯一匹配到相应实参的情况下可以任意组合
 　函数的位置传参要先于关键字传参
 示例：
 　1.函数的位置传参和序列传参可以混合使用，顺序可以颠倒
 　　myfun1(100,*[200,300])
 　　myfun1(*[100,200],300)
 　　myfun1(*[100],200,*[300])
 　2.函数位置传参和关键字传参可以混合使用，但是函数的位置传参要先于关键字传参
 　　myfun1(100,c=300,b=200)
 　　myfun1(100,**{'c':300},b=200)
＝＝＝＝＝＝＝＝＝＝＝以下讲的是函数的定义及函数的形参＝＝＝＝＝＝＝＝＝＝＝＝＝＝


>>>>>>>>>>函数的缺省参数：
 语法：
 def 函数名(形参名1=默认实参，形参2=默认实参2,...):
     语句块
 示例：
 -----
 def info(name,age=1,address='不详'):
     print(name,"今年",age,'岁','家庭住址:',address)
 info('kinpoll',24,'西安高新')
 info("Tarena",16)#当调用不给实参，返回形参的默认实参
 -----
 说明：
 １．缺省参数必须自右至左依次存在，如果一个参数有缺省参数，则其右侧的所有参数都必须有缺省参数
 ２．缺省参数可以有0个，1个或多个，甚至全部都是缺省参数
 示例：
 def fn(a,b=10,c):    #error
     pass
 def fn(a,b=10,c=20): #right
     pass
 
 练习：
 写一个函数myadd，此函数可以计算两个数，三个数及四个数的和，
 如：
 def myadd(...):
     ...
 print(myadd(10,20))#30
 print(myadd(100,200,300))#600
 print(myadd(1,2,3,4))#10
 ----------
 def myadd(a,b,c=0,d=0):
     return a+b+c+d
 print(myadd(10,20))#30
 print(myadd(100,200,300))#600
 print(myadd(1,2,3,4))#10
 -------------
 

>>>>>>>>>>函数形参的定义形式：
位置形参
星号元祖形参
命名关键字形参
双星号字典形参
=======================  
1.位置形参：
 语法：
 def 函数名（形参名1,形参名２,...）:
     语句块
 
2.星号元祖形参：
 语法：
 def 函数名(*元祖形参名):
     语句块
 作用：　
 收集多余的位置传参
 说明：实参个数必须与形参个数相同元祖形参名一般命名为'args'
 示例：
 -----------
 def func(*args):
     print("用户传入的参数个数是：",len(args))
     print('args=',args)
 func()#无参调用
 func(1,2,3)
 func(1,2,3,'AAA','BBB','CCC')
 ------------
 练习：
 ①.写一个函数mysum可以传入任意个数字的实参，此函数调用将返回实参的和
 -----------------
 def mysum(*args):
     s=0
     for x in args:
         s+=x
     return s
 print(mysum())
 print(mysum(1,2,3))
 -------------------
 ②.写一个min_max(...)函数，此函数至少要传一个参数，并返回全部这些数的最小值，最大值（形成元祖，最小在前，最大在后）
 调用此函数，得到最小值和最大值并打印出来
 如：
 def min_max(...):
     ...
 print(min_max(10,20,30))#(10,30)
 x,y=min_max(8,6,4,3,9,2,1)
 print('最小值是：',x)
 print('最大值是：',y)
 print(min_max()) #没有实参报错
 #方法一　－－－－－－－－－－－－－－－
 def min_max(a,*args):
     return (min(a,*args),max(a,*args))
 print(min_max(10,20,30))#(10,30)
 x,y=min_max(8,6,4,3,9,2,1)
 print('最小值是：',x)
 print('最大值是：',y)
 print(min_max()) #没有实参报错
 #方法二　－－－－－－－－－－－－－－－－－
 def min_max(a,*args):
     zuixiao=a
     for x in args:
         if x <zuixiao:
             zuixiao=x
     zuida=a
     for x in args:
         if x>zuida:
             zuida=x
     return (zuixiao,zuida)
 print(min_max(10,20,30))#(10,30)
 x,y=min_max(8,6,4,3,9,2,1)
 print('最小值是：',x)
 print('最大值是：',y)
 print(min_max()) #没有实参报错
 #－－－－－－－－－－－－－－－－－－－－－


3.命名关键字形参：
 语法：
 def 函数名(*,命名关键字形参１，命名关键字2,...):
     语句块
 #或
 def 函数名(*args,命名关键字形参１，命名关键字2,...):
     语句块
 作用：强制所有的命名关键字形参都必须用关键字传参或字典关键字传参
 示例：
 －－－－－－－－－－－－－－－－－－－－－－
 def f1(*,c,d):
     print('c=',c)
     print('d=',d)
 f1(d=4,c=3)#正确
 d1={'c':30,'d':40}
 f1(**d1)
 f1(3,4)#报错
 －－－－－－－－－－－－－－－－－－－－－
 def f2(a,b,*,c,d):
     print(a,b)
     print(c,d)
 f2(1,2,d=200,c=100)
 －－－－－－－－－－－－－－－－－－－－－
 def f2(a,b,*args,c,d):
     print(a,b)
     print(args)
     print(c,d)
 f2(1,2,3,4,d=200,c=100)
 f2(11,22,33,**{'c':11,'d':22})　
 －－－－－－－－－－－－－－－－－－－－－－
 
4.双星号字典形参：
 语法：
 def 函数名(**字典形参名)：
     语句块
 作用：
 收集多余的关键字形参
 说明：
 字典形参名一般命名为"kwargs"
 示例：
 --------------------------
 def fun(**kwargs):
     print('关键字传参个数是：',len(kwargs))
     print('kwargs=',kwargs)
 fun(a=1,b='BBBB',c=[2,3,4])#{'a':1,'b':BBBB,'c':[2,3,4]}
 fun()#{}
 ----------------------------
  
 
 
>>>>>>>>>>函数的参数说明：
 位置形参，星号元祖形参，命名关键字形参，双星号字典形参，缺省参数可以混合使用
 示例：
 def fx(a,b,*args,c,d,**kwargs):
     pass
 fx(1,2,3,4,5,c='C',d='D',e='E')
 #可以接收任意的位置传参和关键字传参的函数：
 -------------------------------------------
 def fn(*args,**kwargs):
     print('args=',args)
     print('kwargs=',kwargs)
 fn()
 fn(1,2,3,4,5,6,7,8)
 fn(a=1,b=2)
 fn(1,2,*'ABCD',*[11,22],3,c=100,**{'a':200})  #位置传参全部传到元祖，关键字传参全部传到字典里
 ----------------------------------------------
　
　　
　
思考题：
１．查看>>>help(print)猜想print()函数是如何定义的？
 -----------------------------------------------
 def myprint(*args,sep=' ',end='\n'):
     print(*args,sep=sep,end=end)
 myprint()
 myprint(1,2,3,4)
 myprint(1,2,3,4,sep='#')
 myprint(1,2,3,4,sep='#',end='\n\n')
 myprint('====================')
 -----------------------------------------------
２．查看>>>range()函数猜想它的形参列表是如何定义的？
 -------------------------------------------------
 def myrange(a,b=None,c=None):
     if b is None:
         start=0
         stop=a
     else:
         start=a
         stop=b
     if c is None:
         step=1
     else:
         step=c
     return list(range(start,stop,step))
 L=myrange(4)
 print(L)#[0,1,2,3]
 L=myrange(4,6)
 print(L)#[4,5]
 L=myrange(1,10,3)
 print(L)#[1,4,7]
 --------------------------------------------------
　

全局变量和局部变量：
>局部变量：
 定义在函数内部的变量称为局部变量（函数的形参也是局部变量）
 局部变量只能在函数内部使用
 局部变量在函数调用时才能够被创建，在函数调用之后会自动销毁
 
>全局变量：
 定义在函数外部，模块文件内部的变量称为全局变量
 全局变量，所有的函数都可以直接访问（但不能直接将其赋值）
示例：
 －－－－－－－－－－－－－－－
 a=100#全局变量
 b=200#全局变量
 def fx(c): #c是局部变量
     d=400#d是局部变量
     a=10000
     print(a,b,c,d)
 fx(300)#10000 200 300 300 400  优先访问函数的局部变量a
 print('a=',a)#a=100　　　　　　　函数调用结束后局部变量销毁，访问全局变量
 print('c=',c)#error:name 'c' is not defined
 －－－－－－－－－－－－－－－  
说明：
 1.在函数内部的赋值语句会创建局部变量，不会对全局变量造成影响
 2．局部变量只能在其被声明的函数内部访问，而全局变量可以在整个模块范围内访问

globals()和locals()函数
 globals()返回当前全局作用域内变量的字典
 locals()返回当前局部变量作用域内变量的字典
示例：
 －－－－－－－－－－－－－－－
 a=1
 b=2
 c=3
 def fn(c,d):
     e=300
     print('locals()返回',locals())
     print('globals()返回',globals())
     print(c)#访问局部变量c的值
     print(globals()['c'])#访问局部变量c的值
 fn(100,200)
 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
 －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
# 练习：
# １．写一个函数is_prime(x)判断x是否是素数，如果是素数返回True，否则返回Fasle
# def is_prime(x):
#     ....
# print(is_prime(4))#False 
# print(is_prime(5))#True     
# -----------------------------------------------------------------------
def is_prime(x):
    if x<2:
        return False
    for i in range(2,x):
        if x%i==0:
            return False
    return True
print(is_prime(4))#False 
print(is_prime(5))#True
print(is_prime(9))
# -----------------------------------------------------------------------
# ２．写一个函数prime_m2n(m,n)返回从m开始到n结束的范围内的素数（不包含n），返回这些素数的列表，并打印
# 如：
# L=prime_m2n(5,10)
# print(L)#[5,7]
# -----------------------------------------------------------------------
def prime_m2n(m,n):
    lst=[]
    for a in range(m,n):
        if is_prime(a):
            lst.append(a)
        else:
            continue
    return lst
L=prime_m2n(5,10)
print(L)#[5,7]

# -----------------------------------------------------------------------
# ３．写一个函数primes(n)返回指定范围n以内的素数（不包含n）的全部素数的列表，并打印这些素数
# L=primes(10)
# print(L)#[2,3,5,7]
# ①打印100以内的全部素数
# ②打印200以内的全部素数的和
# -----------------------------------------------------------------------
def primes(n):
    return prime_m2n(0,n)
L=primes(10)
print(L)
print(primes(100))
print(sum(primes(200)))
# -----------------------------------------------------------------------
# ４．改写之前的学生信息管理程序：
# 改为两个函数实现：
# ①写函数input_student()来获取学生的信息，当输入姓名为空时结束输入，形成字典组成的列表，并返回
# ②写函数print_student(L)将上述函数得到的打印成为表格显示
# 如：
# def input_student():
#     ...
# def print_student(L):
#     ...
# L=input_student()#获取列表
# print(L)
# print_student(L)#打印表格
# -----------------------------------------------------------------------
def input_student():    
    lst=[]
    while True:
        x=input("请输入姓名:")
        if x=='':
            break
        y=input("请输入年龄:")
        z=input("请输入成绩:")
        d={'name':x,'age':y,'score':z}
        lst.append(d)
    return lst
def print_student(L):
    print('+'+'-'*10+'+'+'-'*10+'+'+'-'*10+'+')
    print('|'+'name'.center(10)+'|'+'age'.center(10)+'|'+'score'.center(10)+'|')
    print('+'+'-'*10+'+'+'-'*10+'+'+'-'*10+'+')
    i=0
    while i<=(len(L)-1):
        print('|'+L[i]['name'].center(10)+'|'+L[i]['age'].center(10)+'|'+L[i]['score'].center(10)+'|')
        i+=1
    print('+'+'-'*10+'+'+'-'*10+'+'+'-'*10+'+')

L=input_student()#获取列表
print(L)
print_student(L)#打印表格
# -----------------------------------------------------------------------