装饰器decorator(专业提高篇)
作用：
通常在不改变原函数的情况下，改变或添加原函数的功能
什么是装饰器
装饰器是一个函数，能用来包装另一个函数或类（后面才讲）
函数装饰器
是指装饰器函数，传入的是函数，返回的也是函数
语法：
def 装饰器函数名(形参):
    语句块
    return 函数对象
@装饰器函数名1
@装饰器函数名2
@装饰器函数名3


def 函数名(形参列表):
    语句块

示例：
---------------------------------------------------------
#以下是装饰器函数，fn用来绑定被装饰函数
def mydeco(fn):
    def fx():
        print('+++++这是fn被调用之前')
        fn()
        print('-----这是fn被调用之后')
    return fx
@mydeco
def myfunc():
    print('myfunc被调用！')
#以上@mydeco等同于在def myfuc之后加了如下语句：
#myfunc=mydeco(myfunc)
myfunc()
#+++++这是fn被调用之前
#myfunc被调用！
#-----这是fn被调用之后
------------------------------------------------------------------------------------
#此示例用装饰器改变原来函数的调用流程（业务流程）
#银行业务
#--------以下是魏小明同学写的程序----------
#此装饰器用来增加权限验证功能
def privilege_check(fn):
    def fx(n,x):
        print('正在进行权限验证...')
        fn(n,x)
    return fx
#此装饰器用来增加短消息提醒功能
def message_send(fn):
    def fy(n,x):
        fn(n,x)
        print('正在发送短消息给',n,'...')
    return fy 



#--------以下是魏老师写的程序----------
@privilege_check
def save_money(name,x):
    print(name,'存钱',x,'元')
@message_send
@privilege_check
def withdraw(name,x):
    print(name,'取钱',x,'元')
#--------以下是小张写的程序------------
save_money('小王',200)
save_money('小赵',400)
withdraw('小李',500)
#正在进行权限验证...
#小王 存钱 200 元
#正在进行权限验证...
#小赵 存钱 400 元
#小李 取钱 500 元
--------------------------------------------------------------------------------------------


函数的文档字符串
函数内第一次末赋值给任何变量的字符串是函数的文档字符串
语法：
def 函数名（参数列表）:
    '函数的文档字符串'
    函数语句块
示例:
def cba():
    """这是一块文档字符串
    以下省略300字..."""
    pass
>>>help(cba)

函数的__doc__属性
__doc__属性用于记录函数的文档字符串
如：
print(cba.__doc__)


-----------------------------------------------------------------------------------------
函数定义语句（def 语句）的完整语法：
[@装饰器名１]
[@装饰器名２]
[．．．]
def 函数名([位置形参],[*元祖形参],[命名关键字形参],[**字典形参])：
    '文档字符串'
    语句块

-----------------------------------------------------------------------------------------
面试题：
L=[1,2]
def f(n,lst=[]):
    '''lst绑定的列表[]会在def语句创建时创建，且和f绑定的数值一直存在'''
    lst.append(n)
    print(lst)
f(3,L)#[1,2,3]
f(4,L)#[1,2,3,4]
f(100)#[100]
f(200)#[100,200]－－－－？

解决办法：
#以上函数改写如下：
def f(n,lst=None):
    if lst is None:
        lst=[]
    lst.append(n)
    print(lst)
-----------------------------------------------------------------------------------------


模块Module
什么事模块：
 模块是包含一系列数据，函数，类等组成的程序组
 模块是一个文件，模块文件通常以.py结尾
作用：
 让一些相关的数据，函数，类等有逻辑的组织在一起，使逻辑结构更加清晰
 模块中的数据，函数和类的个可提供给其他模块或程序使用
模块的分类：
 1.内置模块，在解析器内部可以直接使用(通常用C语言编写)
 2.标准库模块，安装python时已安装，且可以直接使用
 3.第三方模块(通常为开源，需要自己安装)
 $pip3 install xxxx
 4.用户自己编写的模块(也可以作为其他人的第三方模块)

模块的导入语句：
import语句
语法：
import 模块名1 [as 模块新名1],模块名2 [as 模块新名2],...
作用：
将某模块整体导入当前模块
用法：
模块名.属性名
如：
import math
print(math.factorial(5))
print('圆周率为：',math.pi)　

-----------------------------------------------------------------------------------------
dir(obj)函数：返回模块内所有属性的字符串列表
help(模块名)可以查看模块相关的文档字符串
-----------------------------------------------------------------------------------------
练习：
１．输入一个圆的半径，打印这个圆的面积
２．输入一个圆的面积，打印这个圆的半径
（要求用math模块内的函数和数据）
-----------------------------------
import math as m
a=float(input('输入一个圆的半径:'))
print('这个圆的面积为：',round(pow(a,2)*m.pi,2))
s=float(input('输入一个圆的面积:'))
print('这个圆的半径为：',round(m.sqrt(s/m.pi),2))
-------------------------------------------------

from import 语句
语法：　
from 模块名　import　模块属性名１　[as 属性新名1],模块属性名2 [as 属性新名2]
作用：
将某个模块的一个或多个属性导入到当前模块的作用域内
示例：
from math import sin
from math import pi,e,cos
form math import factorial as fac 
print(sin(pi/2))*fac(5))

-------------------------------------------------
from import *语句
语法：　
from 模块名　import*
作用：　
将某模块的所有属性导入到当前模块
示例：
from math import *
print(sin(pi/2))
print(factorial(5))
-------------------------------------------------

dir函数：
dir([对象])　返回一个字符串列表
作用：
 １．如果没有参数，则返回当前作用域内所有变量的列表
 ２．如果给定一个对象作为参数，则返回这个对象的所有变量的列表
   1)对于一个模块，返回这个模块的全部变量
   2)对于一个类，返回类的所有变量，并递归基类对象的所有变量
   3)对于其他对象返回所有变量，类变量和基类变量
-------------------------------------------------

数学模块math
模块名：math
数学模块用法：

import math
# 或
from math import *

数据 	　描述
math.e 	自然对数的底e
math.pi 	圆周率pi
函数名 	　　　　　　描述
math.ceil(x) 	对x向上取整，比如x=1.2，返回2
math.floor(x) 	对x向下取整，比如x=1.2，返回1
math.sqrt(x) 	返回x的平方根
math.factorial(x) 	求x的阶乘
math.log(x[, base]) 	返回以base为底x的对数, 如果不给出base,则以自然对数e为底
math.log10(x) 	求以10为底x的对数
math.pow(x, y) 	返回 x**y (x的y次方)
math.fabs(x) 	返回浮点数x的绝对值
角度和弧度degrees互换 	
math.degree(x) 	将弧度x转换为角度
math.radians(x) 	将角度x转换为弧度
三角函数 	
math.sin(x) 	返回x的正弦(x为弧度)
math.cos(x) 	返回x的余弦(x为弧度)
math.tan(x) 	返回x的正切(x为弧度)
math.asin(x) 	返回x的反正弦(返回值为为弧度)
math.acos(x) 	返回x的反余弦(返回值为为弧度)
math.atan(x) 	返回x的反正切(返回值为为弧度)
-------------------------------------------------
时间模块
模块名:time
函数名 	描述
******************************************************************************
>>>>>time.time() 	　　　 　返回从计算机元年至当前时间的秒数的浮点数(UTC时间为准)　　 * 
>>>>>【1970年截止目前过了多少秒】                                                *
******************************************************************************
time.sleep(secs) 	　     让程序按给定秒数的浮点数睡眠一段时间  　　　  　　　  　　 *
time.gmtime([secs]) 	 　用给定秒数转换为用UTC表达的时间元组(缺省返回当前时间元组)  *
time.asctime([tuple]) 　   将时间元组转换为日期时间字符串                　　      *
******************************************************************************
>>>>>time.mktime(tuple)　　　　  将本地日期时间元组转换为新纪元秒数时间(UTC为准)　　　 
>>>>>【返回从1970～（给定时间点元祖）计算后的秒数】
*********************************************************************************************************************
>>>>>time.localtime([secs])　   将UTC秒数时间转换为日期元组（以本地时间为准)　 　　 　                      　      　       *
>>>>>【给定(1970～20xx)的秒数，返回元祖(x年，x月，x日，x时，x分，x秒，星期x，元旦开始日 (1-366)，夏令时修正时间 (-1, 0 or 1))】　 *
*********************************************************************************************************************

练习：
写一个程序，输入你的生日
①计算你已经出生多少天？
②算出你出生那天是星期几？

－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
import time
year=int(input('请输入出生年'))
month=int(input('请输入出生月'))
day=int(input('请输入出生日'))
cur_seconds=time.time()
birth_seconds=time.mktime((year,month,day,0,0,0,0,0,0))
life_seconds=cur_seconds-birth_seconds
n=life_seconds/3600//24
print('您已出生%d天' %  n)

t=time.localtime(birth_seconds)
d={0:'星期一',1:'星期二',2:'星期三',3:'星期四',4:'星期五',5:'星期六',6:'星期七'}
print('您出生那天是%s' % d[t[6]])
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
系统模块sys
运行时系统相关信息
模块名：sys

sys模块的数据
数据 	描述
sys.path 	模块搜索路径 path[0] 是当前脚本程序的路径名，否则为 ''
sys.modules 	已加载模块的字典
sys.version 	版本信息字符串
sys.version_info 	版本信息的命名元组
sys.platform 	操作系统平台名称信息
sys.argv 	命令行参数 argv[0] 代表当前脚本程序路径名
sys.copyright 	获得Python版权相关的信息
sys.builtin_module_names 	获得Python内建模块的名称（字符串元组）
sys模块的函数
函数名 	描述
sys.exit([arg]) 	退出程序，正常退出时sys.exit(0)
sys.getrecursionlimit() 	得到递归嵌套层次限制（栈的深度）
sys.setrecursionlimit(n) 	得到和修改递归嵌套层次限制（栈的深度）

------------------------------------
# 1.编写函数fun，其功能是计算下列多项式的和
# f(n)=1+1/1!+1/2!+1/3!+...+1/n!
# 求当n等于20时，求此函数的值
#---------------------------------------------------
# import math
# def fun(n):
#     return sum([1/math.factorial(x) for x in range(1,n)])
# print(fun(20))
#---------------------------------------------------
# ２．写一个程序，以电子时钟格式显示时间:
# 格式为：
# HH:MM:SS 如：15:58:26
#---------------------------------------------------
import time
while True:
    t=time.localtime()
    print('%d:%d:%d' % t[3:6],end='\r')
    time.sleep(1)
#---------------------------------------------------
# 3.编写一个闹钟程序，启动时设置定时时间，到时间后打印一句'时间到！'，然后退出程序
#---------------------------------------------------
# import time
# import sys
# hour=int(input('请输入设定小时数：'))
# minute=int(input('请输入设定分钟数：'))
# second=int(input('请输入设定秒数：'))
# set_second=time.mktime((2018,9,18,hour,minute,second,0,0,0))
# cur_second=time.time()
# pass_second=float(set_second-cur_second)
# time.sleep(pass_second)
# print('时间到！')
# sys.exit(0)
#另外的方法：---------------------------------------------------
import time
def alarm(h,m,s):
    t=time.localtime()
    p=t[3:6]
    while p==(h,m,s):
        print('时间到！')
        break    
while True:
    t=time.localtime()    
    print('%d:%d:%d' % t[3:6],end='\r')
    alarm(19,50,00)
    time.sleep(1)
----------------------------------------------------------------