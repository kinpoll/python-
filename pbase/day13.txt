自定义模块
要求：
模块文件名后缀必须以.py结尾
模块文件名必须是合法标识
避免名称和内建模块冲突
导入方式：
import 自定义模块名
from　自定义模块名　import 属性
from 自定义模块名　import　*
示例：
# #此示例示意自定义模块mymode及导入用法
# def mysum(n):
#     print('正在计算1+2+3+...+',n,'的和')
# def myfac(n):
#     print('正在计算%d!...' % n)
# name1='Audi'
# name2='Tesla'
# print('mymode模块被加载')
----------------------------以上保存为xx.py文件
----------------------------以下调用必须和以上模块必须在同一个文件夹下

# #此示例示意导入自定义模块并调入其中的函数
# import mymod
# mymode.mysum(100)
# print(mymode.name1)

# from mymode impore myfac as fac 
# fac(6)

# from mymode import *
# mysum(20)
# print(name2)

------------------------------------
import　语句　搜索模块的路径顺序
１．搜索内建模块
２．搜索程序运行时路径（当前工作目录）
３．搜索sys.path提供的路径
可以在sys.path里添加自定义路径
如：
import sys
sys.path.append['/home/tarena/桌面/aid1808']
import student_info 
#可以导入/home/tarena/student_info.py这个模块　
---------------------------------------------------------
模块化编程的优点：
１．有利于多人合作开发
２．使代码更加容易维护
３．提高代码的复用率
４．模块化编程有利于解决函数名和变量名冲突(模块内变量的作用域为模块内全局)

模块的加载过程：
在模块导入时，模块内的所有语句会执行
如果一个模块已经导入，则再次导入时不会执行模块内的语句

模块的重新加载：
import student_info
import imp 
imp.reload(student_info)#重新加载mymode模块

模块被导入和执行的过程：
１．搜索相关的路径找模块文件.py文件
２．判断是否有此模块对应的.py文件.如果pyc文件与.py文件新则直接加载pyc文件，否则用.py文件重新生成.pyc文件并加载

pyc模块的编译
             编译　　　　　　　　执行
mymode.py---->mymode.pyc---->python3


模块的预置属性：
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
__doc__属性　
 绑定模块的文档字符串
 模块的文档字符串是模块内第一个没有赋值给任何变量的字符串
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
__file__属性　
 绑定模块所对应的文件路径名
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
__name__属性　
 作用：
  １．记录模块名
  ２．用来判断是否为主模块
 说明：
  １．当此模块为主模块运行时，__name__绑定'__main__'
  ２．当此模块不是主模块运行时，而是被其他模块导入时，此模块名为模块文件.py前面的模块名
      如：mymode.py的模块名为mymode 
 注：主模块是指先被python解释执行器执行的模块
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
__all__列表
 __all__列表是一个用来存储可导入属性的字符串系列表
 作用：
 限制用from xxx import *语句导入时导入部分属性，而不是全部属性
 示例：
 #此示例示意模块内的__all__列表的定义方式和作用
 #限制　别人用from import*语句导入时，只能导入：f3,var1
 __all__=['f3','var1']
 def f1():
     pass
 def f2():
     f1()
 def f3():
     f2()
 var1='aaaa'
 var2='bbbb'
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
模块的隐藏属性：
模块中以'_'开头的属性，在from xx import*导入时将不被导入，通常称这些属性为隐藏属性
示例：
#此示例示意隐藏属性,在用from mymode import* 语句导入时，只能导入f,name1属性
def f():
    pass
def _f():
    pass
def __f():
    pass
name1='aaa'
_name2='bbb'
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝


随机模块random
作用：
用于模拟或生成随机输出的模块
用法示意:
import random as R
函数名 	                                 描述
R.random()                              返回一个[0, 1) 之间的随机实数
R.uniform(a,b)                          返回[a,b) 区间内的随机实数
R.randrange([start,] stop[, step])      返回range(start,stop,step)中的随机数
R.choice(seq)                           从序列中返回随意元素
R.shuffle(seq[, random])                随机指定序列的顺序(乱序序列）
R.sample(seq,n)                         从序列中选择n个随机且不重复的元素


练习：
猜数字游戏：
随机生成一个0~100之间的整数，用变量x绑定
让用户输入一个数y，输出猜数字结果
①如果y等于生成的数x，则提示'恭喜您猜对了'，并退出程序
②如果y大于x，则提示'您猜大了'，然后继续猜下一次
③如果y小于x，则提示'您猜小了'，然后继续猜下一次
直到猜对为止，最后显示用户猜数字的次数后退出程序
-------------------------------------------
import random as R 
x=R.randrange(101)
n=0
while True:
    y=int(input('请输入一个整数：'))
    n+=1
    if y==x:
        print('恭喜您猜对了')
        break
    if y>x:
        print('您猜大了')
    if y<x:
        print('您猜小了')
print('一共输入%d次' % n)
----------------------------------------------


包（模块包）package
包是将模块以文件夹的组织形式进行分组管理的方法
作用：
将一些列模块进行分类管理，有利于防止名字冲突
可以在需要时加载一个或部分模块而不是全部模块
示例：
mypack/
    __init__.py
    menu.py
    games/
        __init__.py
        contra.py
        supermario.py
        tanks.py
    office/
        __init__.py
        excel.py
        word.py
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
包的导入：
同模块的导入规则相同
语法：
import 包名　[as 包别名]
import 包名.模块名　[as 模块新名]
import 包名.子包名.模块名　[as 模块新名]
．．．
from 包名　import 模块名　[as 模块新名]
from 包名.子包名　import 模块名　[as 模块新名]
from 包名.子包名.模块名　import 属性名　[as 属性新名]
．．．
from 包名　import *
from 包名.模块名　import *
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
__init__.py文件
此文件时常规包内必须存在的文件，此文件会在包被导入时自动调用
作用:
编写此包的内容
在内部填写包的文档字符串
在__init__.py内可以加载此包所依赖的一些其他模块
示例：
mypack/__init__.py 
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

包内的__all__列表
作用：
用来记录此包内有哪些子包或模块在from import*语句导入时需要被导入
说明：
__all__列表只对from xxx import *语句中起作用
示例：
mypack/games/__init__.py 
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－


包的相对导入：(只有from xx import xx 和from xx import *可以用相对导入，import xx 不可以)
包的相对导入是指包内模块的相互导入
语法：
from 相对路径包或模块　import 属性或模块名
或
from 相对路径或模块　import *

相对路径：
．代表当前目录
..代表上一级目录
...代表上二级目录
....以此类推
注：相对导入时不能超出包的外部
示例：
mypack/games/contra.py 
※注意避免循环导入！！！！
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－

包的加载路径：
１．当前工作路径
２．sys.path提供的路径
模块的加载路径设置方法：
sys.path('新路径')





练习：
1. 模拟'斗地主'发牌 
    牌共54张
    花色:
        黑桃('\u2660'), 梅花('\u2663'), 方块('\u2665'), 红桃('\u2666')
    大小王
    数字:
        A0~10JQK
　　1) 生成54张片
　　2) 三个人玩牌，每人发17张,底牌留三张
　　    输入回车, 打印第1个人的17张牌
　　    输入回车, 打印第2个人的17张牌
　　    输入回车, 打印第3个人的17张牌
　　    输入回车, 打印3张底牌
-------------------------------------------------------------------------------------------------------
L=['A']+[str(x) for x in range(2,11)]+list('JQK')
kind=['\u2660','\u2663','\u2665','\u2666']
poke=['JOKER','joker']
for x in kind:
    for y in L:
        poke.append(x+' '+y)
poke1=list(poke)
import random as R 
R.shuffle(poke1)
input()
print("第1个人的17张牌是:", poke1[:17])
input()
print("第2个人的17张牌是:", poke1[17:34])
input()
print("第3个人的17张牌是:", poke1[34:51])
input()
print("底牌是:", poke1[51:])
-----------------------------------------------------------------------------------------------------------

 2. 将学生信息管理程序拆分成相应的模块:
        建议:
            main.py  # 放主事件循环 main函数及其关相函数
            menu.py  # 放菜单相关的函数show_menu()
            student_info.py  # 放学生信息操作相关的函数
-------------------------------------------------------------------
import time
print('学生信息管理系统即将启动')
time.sleep(2)
from menu import table
table()
from main import student_info_manage
student_info_manage()
print('学生信息管理系统即将退出')
time.sleep(2)
-------------------------------------------------------------------



