生成器　Generator(pyhton2.5及以后)
生成器是指能够动态提供数据的可迭代对象
生成器是在运行时生成数据，与容器类不同，他通常不会再内存中保存大量的数据，而是现用现生成
生成器有两种：
１．生成器函数
２．生成器表达式

生成器函数：
　含有yield语句的函数是生成器函数，此函数被调用将返回一个生成器对象
　yield翻译为(产生或生成)
yield语句
语法：
　yield 表达式
说明：
　yield用于def函数中，目的是将此函数作为生成器函数使用
　yield用来生成数据，供迭代器的next(it)函数取值
示例：
-------------------------------------------------------------
#gen_function.py 
#此示例示意生成器函数的定义和使用
def myyield():
    '''这是一个生成器函数，此函数用动态生成2,3,5,7'''
    yield 2
    yield 3
    yield 5
    yield 7
# 用迭代器访问生成器函数
gen=myyield()#生成器函数调用将返回一个生成器
print(gen)#gen是生成器对象
# print([x for x in gen])
n=0
while n<4:
    print(next(iter(gen)))
    n+=1
----------------------------------------------------------
#此示例示意生成器函数的定义和使用
def myyield():
    print('即将生成２')
    yield 2
    yield 3
    yield 5
    yield 7
    print('生成器函数调用结束')
gen=myyield()
it=iter(gen)
print(next(it))
print(next(it))
print(next(it))
print(next(it))
print(next(it))
-----------------------------------------------------------
生成器函数说明:
  生成器函数的调用将返回一个生成器对象，生成器对象是一个可迭代对象，通常用来动态生成数据
  生成器函数调用 return 语句会触发一个StopIterator异常
--------------------------------------------------------------------
#此示例示意用生成器函数创建生成从０开始到n结束的一系列整数(不包含n)
def myinteger(n):
    i=0
    while i<n:
        yield i
        i+=1
for x in myinteger(5):
    print(x)
-------------------------------------------------------------------
练习：
写一个生成器函数myeven(start,stop)用来生成从start开始到stop结束区间内的一系列偶数(不包含Stop)
如：
def myeven(start,stop):
    ...
evens=list(myeven(10,20))
print(evens)#[10,12,14,16,18]
for x in myeven(5,10):
    print(x)#6 8
L=[x for x  in myeven(0,10)]
print(L)#[0,2,4,6,8]
---------------------------------------------------------
def myeven(start,stop):
    
    while start<stop:
        if start%2==0:
            yield start
        start+=1
evens=list(myeven(10,20))
print(evens)#[10,12,14,16,18]
for x in myeven(5,10):
    print(x)#6 8
L=[x for x in myeven(0,10)]
print(L)#[0,2,4,6,8]
-----------------------------------------------------------
生成器表达式：
语法：
(表达式　for 变量 in 可迭代对象　[if 真值表达式])
说明：
if子句可以省略
作用：
用推导式形式生成一个新的生成器
示例：
gen=(x**2 for x in range(1,5))
it=iter(gen)
print(next(it))#1
print(next(it))#4
print(next(it))#9
print(next(it))#16
print(next(it))#StopIteration
------------------------------------------------------------
练习：
已知有列表：
L=[2,3,5,7,10,15]
1)写一个生成器函数，让此函数能动态提供数据，数据为原列表的数字的平方+1
2)写一个生成器表达式，让此表达式能动态提供数据，数据依旧为原列表的数字的平方+1
3)生成一个列表，此列表内的数据是原列表数据的平方加1
-------------------------------------------
L=[2,3,5,7,10,15]
def myyield(L):
    for x in L:
        yield x**2+1
L1=list(myyield(L))
#----------------------------------
L2=list((x**2+1 for x in L))
#----------------------------------
L3=[x**2+1 for x in L]
print(L1,L2,L3,sep='\n')
---------------------------------------------
# gen_vs_list_comprehension.py

L = [2, 3, 5, 7]
L2 = [x *10 for x in L]
it = iter(L2)
print(next(it))  # 20
L[1] = 30
print(next(it))  # 30

# 以下是生成器表达式
L = [2, 3, 5, 7]
gen = (x *10 for x in L)
it = iter(gen)
print(next(it))  # 20
L[1] = 30
print(next(it))  # 300
------------------------------------------------
迭代工具函数：
作用：
生成一个个性化的可迭代对象
函数　　　　
说明
>zip(iter1 [, iter2[....]])  
 返回一个zip生成器对象,此对象用于生成元组，此元组的每个数据来源于参数中的可迭代对象，生成元祖的个数由最小的可迭代对象大小决定

>enumerate(iterable [, start]) 
 返回一个enumerate生成器对象，此对象生成类型为(索引，值)的元祖，默认索引从零开始,也可以用start指定
-----------------------------------------------------------------------------------------------------------------------
zip示例:
-----------------------------------------------------------------------------------------------------------------------------------
numbers = [10086, 10000, 10010, 95588]
names = ['中国移动', '中国电信', '中国联通']
for t in zip(numbers, names):
    print(t)
d=dict(zip(numbers,names))
print(d)
#(10086, '中国移动')
#(10000, '中国电信')
#(10010, '中国联通')
#{10000: '中国电信', 10010: '中国联通', 10086: '中国移动'}
-------------------------------------------
numbers = [10086, 10000, 10010, 95588]
names = ['中国移动', '中国电信', '中国联通']
for No, number, name in zip(range(1, 100),numbers,names):
    print("序号",No, name, '的客服电话是:', number)
#序号 1 中国移动 的客服电话是: 10086
#序号 2 中国电信 的客服电话是: 10000
#序号 3 中国联通 的客服电话是: 10010
----------------------------------------------
zip函数的实现（生成器函数的实现）：
示例：
def myzip(iter1,iter2):
    #先拿到两个对象的迭代器
    it1=iter(iter1)
    it2=iter(iter2)
    while True:
        try:
            a=mext(it1)
            b=next(it2)
            yield (a,b)
        except StopIteration:
            return#次生成器函数到此结束

--------------------------------------------------------------------------------------------------------------------------------
enumerate示例：
-----------------------
names = ['中国移动', '中国电信', '中国联通']
for t in enumerate(names):
    print(t)
d=dict(enumerate(names))
print(d)
#(0, '中国移动')
#(1, '中国电信')
#(2, '中国联通')
#{0: '中国移动', 1: '中国电信', 2: '中国联通'}
-----------------------------------------------
练习：
写一个程序，读入任意行的文字，当输入空行时结束输入
打印带有行号的输入结果
如：
请输入：tarena<回车>
请输入：china<回车>
请输入：holiday<回车>
请输入：<回车>
输出如下：
第1行：tarena
第2行：china
第3行：holiday
--------------------------------------------------

def get_input_text():
    L=[]
    while True:       
        x=input('输入任意字符:')
        if not x:
            return L
        L.append(x)
def print_text_with_number(L):
    for x in enumerate(L,1):
        print('第%d行:%s' % x)
print_text_with_number(get_input_text())
-----------------------------------------------------
字节串和字节数组
回顾：
　序列：
　　列表，元祖，字符串，字节串，字节数组
-------------------------------------------------------------------------
字节串（也叫字节序列）bytes
　作用：
　　存储以字节为单位的数据
　说明：
　　字节串是不可改变的序列
-------------------------------------------------------------------------
字节byte:
　　字节是0~255之间的数，用来表示字节的取值
位bit:
1byte=8bit
-------------------------------------------------------------------------
创建空字节串的字面值：
b''
b""
b''''''
b""""""
-------------------------------------------------------------------------
创建非空的字节串字面值
b'ABCD'
b"ABCD"
b'\x41\x42\x43\x44'
b'中文'　#错误
-------------------------------------------------------------------------
字节串的构造函数bytes；
bytes() 生成一个空的字节串，等同于b''
bytes(整型可迭代对象)#用可迭代对象初始化一个字节串
bytes(整数n)#生成n个值为0的字节串
bytes(字符串，encoding='utf-8')用字符串的转换编码生成一个字节串
示例：
b=bytes()#b=b''
b=bytes(range(65,70))#b=b'ABCDE'
b=bytes(5)#b=b'\x00\x00\x00\x00\x00'
b=bytes('ABC','utf-8')#b=b'ABC'
b=bytes('中文','utf-8')#b=b'\xe4\xb8\xad\xe6\x96\x87'
-------------------------------------------------------------------------
bytes的运算：
同其他的序列的运算规则相同
+ += - -=　* *=
< <= > >= !=
in/not in
 b=b'abc123ABC'
 0x20 in b#True--------------->print(49 in b)#True
索引和切片
能用于字节串和字节数组的函数运算:
len(x)
max(x)
min(x)
sum(x)
any(x)
all(x)
-------------------------------------------------------------------------
bytes和str的区别：
bytes存储字节（字节是0~255之间的整数）
str存储unicode字符(字符是0~65536的整数)
-------------------------------------------------------------------------
bytes与str转换

编码（encode）:
  str------->bytes
  b=s.encode(encoding='utf-8')

解码(decode):
  bytes---------->str
  s=b,decode(encoding='utf-8')
示例：
s='我是中文'
b=s.encode('utf-8')
s2=b.decode('utf-8')
print(bytes('中文','utf-8'))
print('中文'.encode())
#b'\xe4\xb8\xad\xe6\x96\x87'
#b'\xe4\xb8\xad\xe6\x96\x87'
------------------------------------------------------------------------------------------------------------------------
字节数组bytrarray
可变的字节序列
字节数组的构造函数bytearray
 创建函数bytearray

        bytearray()  创建空的字节数组
        bytearray(可迭代对象)同bytes(可迭代对象)
        bytearray(整数n)
        bytearray(字符串, encoding='utf-8')

字节数组的运算规则和字节串的运算规则完全相同

bytearray 的方法:
方法 	              　          说明
B.clear() 	                     清空
B.append(n) 	                 追加一个字节(n为0-255的整数)
B.remove(value) 	             删除第一个出现的字节,如果没有出现，则产生ValueError错误
B.reverse() 	                 字节的顺序进行反转
B.decode(encoding='utf-8') 	
B.find(sub[, start[, end]]) 	
------------------------------------------------------------------------------------------------------------------------
练习：
有一个bytrarray字节数组
ba=bytearray(b'a1b2c3d4')
如何得到字节串'1234'和'abcd'
将上述字节数组改为：
ba=bytearray(b'A1B2C3D4')
-----------------------------
ba=bytearray(b'a1b2c3d4')
b1=bytes(ba[1::2])
b2=bytes(ba[::2])
ba[::2]=b'ABCD'
print(b1,b2,ba,sep='\n')
----------------------------
------------------------------------------------------------------------------------------------------------------------
练习：
1.打印9x9乘法表：
  1x1=1
  1x2=2 2x2=4
  1x3=3 2x3=6 3x3=9
  .....
  1x9=9...............................9x9=81
---------------------------------------------------------------
for i in range(1,10):
    a=1
    while a<=i:
        s=a*i
        print(a,'x',i,'=',s,sep='',end=' ')
        a+=1
    print()
-----------------------------------------------------------------
for line in range(1, 10):
    # 每循环一次打印一行
    for col in range(1, line + 1):
        # 打印一个公式
        print("%dx%d=%d " %
              (col, line, col*line),
              end='')
    print() # 一行完成换行
-----------------------------------------------------------------
2. 写一个生成器函数myxrange([start, ], stop[, step]) 来生成一系列整数
  要求:
  myxrange功能与range功能相同（不允许调用range函数)
  用自己写的myxrange函数结合生成器表达式求1~10内奇数的平方和
------------------------------------------------------------------
def myrange(start,stop=None,step=1):
    if stop==None:
        stop=start
        start=0
    if step>0:
        while stop>start:
            yield start
            start+=step
    if step<0:
        while stop<start:
            yield start
            start+=step
he=sum(x**2 for x in myrange(10) if x%2)
print(he)            
print(he is sum((1**2,3**2,5**2,7**2,9**2)))
--------------------------------------------------------------------
3.写一个myfilter生成器函数，功能与filter函数功能完全相同
  如：　
def myfilter(fn,iter1):
    ....
L=[x for x in myfilter(lambda x:x%2,range(10))] #L=[1,3,5,7,9]
------------------------------------------------------------------------
def myfilter(fn,iteration):
    for x in iteration:
        if fn(x):
            yield x
L=[x for x in myfilter(lambda x:x%2,range(10))]
print(L) #L=[1,3,5,7,9]
---------------------------------------------------------------------------
4.将以前所有的练习自己不看之前的代码重写一遍
--------------------------------------------------------------------------
○堵馬跌!!!!!!!!!!
--------------------------------------------------------------------------








